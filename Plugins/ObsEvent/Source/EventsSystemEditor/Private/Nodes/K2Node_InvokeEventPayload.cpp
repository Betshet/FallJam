// Copyright Out-of-the-Box Plugins 2018-2023. All Rights Reserved.
#include "K2Node_InvokeEventPayload.h"

#include "K2Node_CallFunction.h"	// for UK2Node_CallFunction
#include "Kismet/GameplayStatics.h" // for UGameplayStatics
#include "KismetCompiler.h"			// for FKismetCompilerContext 

#include "ESEvent.h"
#include "ESPayload.h" // for UESPayload

#define LOCTEXT_NAMESPACE "EventsSystemEditor"

namespace
{
	const FName EventPinName = TEXT("EventToInvoke");
}

UK2Node_InvokeEventPayload::UK2Node_InvokeEventPayload(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	NodeTooltip = LOCTEXT("InvokeEventPayloadNodeTooltip", "Invoke an event with an optional payload creation.");
}

//////////////////////////////////////////////////////////////////////////
// UK2Node_ConstructObjectFromClass interface
bool UK2Node_InvokeEventPayload::IsSpawnVarPin(UEdGraphPin* Pin) const
{
	bool EventPinCheck = (Pin->PinName != EventPinName);
	return EventPinCheck && Super::IsSpawnVarPin(Pin);
}

FText UK2Node_InvokeEventPayload::GetBaseNodeTitle() const
{
	return LOCTEXT("InvokeEventPayload_BaseTitle", "Invoke ESEvent with Payload");
}

FText UK2Node_InvokeEventPayload::GetNodeTitleFormat() const
{
	return LOCTEXT("InvokeEventPayload", "Invoke ESEvent with {ClassName} Payload");
}

UClass* UK2Node_InvokeEventPayload::GetClassPinBaseClass() const
{
	return UESPayload::StaticClass();
}

//////////////////////////////////////////////////////////////////////////
// UEdGraphNode interface
void UK2Node_InvokeEventPayload::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();
	
	FCreatePinParams PinParams;
	PinParams.Index = 1; // Place the event pin right after the flow node.

	// Create input pin for event selection
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UESEvent::StaticClass(), EventPinName, PinParams);

	UEdGraphPin* ClassPin = GetClassPin();
	ClassPin->bAdvancedView = true;

	if (ENodeAdvancedPins::NoPins == AdvancedPinDisplay)
	{
		AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
	}
}

void UK2Node_InvokeEventPayload::PinDefaultValueChanged(UEdGraphPin* Pin)
{
	if (Pin == GetClassPin())
	{
		ResetClassPinToAutoGenerated();
	}

	Super::PinDefaultValueChanged(Pin);
}

void UK2Node_InvokeEventPayload::PinConnectionListChanged(UEdGraphPin* Pin)
{
	if (Pin == GetClassPin())
	{
		ResetClassPinToAutoGenerated();
	}

	Super::PinConnectionListChanged(Pin);
}

FText UK2Node_InvokeEventPayload::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	if (TitleType == ENodeTitleType::Type::MenuTitle)
	{
		return GetBaseNodeTitle();
	}

	if (GetClassToSpawn())
	{
		return Super::GetNodeTitle(TitleType);
	}
	else
	{
		return LOCTEXT("InvokeEventPayloadK2Node_NoPayload", "Invoke ESEvent without payload");
	}
}

void UK2Node_InvokeEventPayload::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	UK2Node_CallFunction* CallCreateNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	CallCreateNode->FunctionReference.SetExternalMember(GET_FUNCTION_NAME_CHECKED(UGameplayStatics, SpawnObject), UGameplayStatics::StaticClass());
	CallCreateNode->AllocateDefaultPins();

	UK2Node_CallFunction* CallInvokeNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
	CallInvokeNode->FunctionReference.SetExternalMember(GET_FUNCTION_NAME_CHECKED(UESEvent, Invoke), UESEvent::StaticClass());
	CallInvokeNode->AllocateDefaultPins();

	bool bSucceeded = true;
	UClass* ClassToSpawn = GetClassToSpawn();

	//connect exe
	{
		UEdGraphPin* SpawnExecPin = GetExecPin();
		UEdGraphPin* CallExecPin = CallCreateNode->GetExecPin();
		bSucceeded &= SpawnExecPin && CallExecPin && CompilerContext.MovePinLinksToIntermediate(*SpawnExecPin, *CallExecPin).CanSafeConnect();
	}

	// connect then pin
	{
		UEdGraphPin* SpawnThenPin = GetThenPin();
		UEdGraphPin* InvokeThenPin = CallInvokeNode->GetThenPin();
		bSucceeded &= SpawnThenPin && InvokeThenPin && CompilerContext.MovePinLinksToIntermediate(*SpawnThenPin, *InvokeThenPin).CanSafeConnect();
	}

	//connect class
	{
		UEdGraphPin* SpawnClassPin = GetClassPin();
		UEdGraphPin* CallClassPin = CallCreateNode->FindPin(TEXT("ObjectClass"));
		bSucceeded &= SpawnClassPin && CallClassPin && CompilerContext.MovePinLinksToIntermediate(*SpawnClassPin, *CallClassPin).CanSafeConnect();
	}

	//connect outer
	{
		UEdGraphPin* SpawnOuterPin = GetEventPin();
		UEdGraphPin* CallOuterPin = CallCreateNode->FindPin(TEXT("Outer"));
		bSucceeded &= SpawnOuterPin && CallOuterPin && CompilerContext.CopyPinLinksToIntermediate(*SpawnOuterPin, *CallOuterPin).CanSafeConnect();
	}

	// Connect output actor from 'begin' to 'finish'
	{
		UEdGraphPin* SpawnPayloadPin = CallInvokeNode->FindPin(TEXT("payload"));
		UEdGraphPin* CallReturnValuePin = CallCreateNode->GetReturnValuePin();
		
		bSucceeded &= SpawnPayloadPin && CallReturnValuePin;

		if (bSucceeded)
		{
			CallReturnValuePin->MakeLinkTo(SpawnPayloadPin);
		}
	}

	// Copy transform connection
	{
		UEdGraphPin* SpawnEventPin = GetEventPin();
		UEdGraphPin* CallEventPin = CallInvokeNode->FindPin(TEXT("eventToInvoke"));
		bSucceeded &= SpawnEventPin && CallEventPin && CompilerContext.CopyPinLinksToIntermediate(*SpawnEventPin, *CallEventPin).CanSafeConnect();
	}

	// Connect return pins
	{
		UEdGraphPin* SpawnReturnPin = GetResultPin();
		UEdGraphPin* CallReturnPin = CallCreateNode->GetReturnValuePin();
		CallReturnPin->PinType = SpawnReturnPin->PinType; // Copy type so it uses the right actor subclass

		bSucceeded &= SpawnReturnPin && CallReturnPin && CompilerContext.MovePinLinksToIntermediate(*SpawnReturnPin, *CallReturnPin).CanSafeConnect();
	}


	// Connect exec and 'then' on last node and 'finish'
	{
		UEdGraphPin* SpawnLastThenPin = FKismetCompilerUtilities::GenerateAssignmentNodes(CompilerContext, SourceGraph, CallCreateNode, this, CallCreateNode->GetReturnValuePin(), ClassToSpawn);
		UEdGraphPin* CallThenPin = CallInvokeNode->GetExecPin();

		bSucceeded &= SpawnLastThenPin && CallThenPin;

		if (bSucceeded)
		{
			SpawnLastThenPin->MakeLinkTo(CallThenPin);
		}
	}

	BreakAllNodeLinks();

	if (!bSucceeded)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("K2NodeExpansionFailed", "[EventsSystem] Failed to expand custom node.").ToString(), this);
	}
	else
	{
		// If the expansions was succesful, log a warning if the event pin has no value.
		UEdGraphPin* SpawnOuterPin = GetEventPin();
		const bool bHasEvent = SpawnOuterPin && (SpawnOuterPin->DefaultObject != NULL || SpawnOuterPin->HasAnyConnections());

		if (!bHasEvent)
		{
			CompilerContext.MessageLog.Warning(*LOCTEXT("K2NodeExpansionNoEventWarning", "[EventsSystem] node has no event").ToString(), this);
		}
	}
}

bool UK2Node_InvokeEventPayload::CanUserEditPinAdvancedViewFlag() const
{
	return true;
}

//////////////////////////////////////////////////////////////////////////
// UK2Node interface
FText UK2Node_InvokeEventPayload::GetMenuCategory() const
{
	return LOCTEXT("InvokeEventPayloadK2Node_MenuCategory", "EventsSystem");
}

//////////////////////////////////////////////////////////////////////////
// Helpers
UEdGraphPin* UK2Node_InvokeEventPayload::GetEventPin() const
{
	UEdGraphPin* Pin = FindPin(EventPinName);
	ensure(nullptr == Pin || Pin->Direction == EGPD_Input);
	return Pin;
}

void UK2Node_InvokeEventPayload::ResetClassPinToAutoGenerated()
{
	for (UEdGraphPin* PinIt : Pins)
	{
		if (IsSpawnVarPin(PinIt))
		{
			FString AutoGeneratedValue = PinIt->AutogeneratedDefaultValue;
			PinIt->DefaultValue = AutoGeneratedValue;
		}
	}
}

#undef LOCTEXT_NAMESPACE
